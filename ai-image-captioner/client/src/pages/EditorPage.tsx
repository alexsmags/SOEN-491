import { useEffect, useMemo, useRef, useState } from "react";
import Sidebar from "../components/Sidebar";
import Topbar from "../components/Topbar";
import Footer from "../components/Footer";
import EditorPreview from "../components/Editor/EditorPreview";
import EditorControls from "../components/Editor/EditorControls";
import preview_img from "../assets/preview_image.jpg";

type View = "mobile" | "tablet" | "desktop";
function useView(): View {
  const getView = () => {
    if (typeof window === "undefined") return "desktop" as View;
    if (window.matchMedia("(max-width: 767px)").matches) return "mobile";
    if (window.matchMedia("(min-width: 768px) and (max-width: 1023px)").matches) return "tablet";
    return "desktop";
  };
  const [view, setView] = useState<View>(getView);
  useEffect(() => {
    if (typeof window === "undefined") return;
    const mqs = [
      window.matchMedia("(max-width: 767px)"),
      window.matchMedia("(min-width: 768px) and (max-width: 1023px)"),
      window.matchMedia("(min-width: 1024px)"),
    ];
    const onChange = () => setView(getView());
    mqs.forEach((mq) => mq.addEventListener("change", onChange));
    return () => mqs.forEach((mq) => mq.removeEventListener("change", onChange));
  }, []);
  return view;
}

export default function EditorPage() {
  const view = useView();

  const [collapsed, setCollapsed] = useState<boolean>(() => {
    const saved = typeof window !== "undefined" ? localStorage.getItem("sidebar-collapsed") : null;
    return saved ? saved === "1" : false;
  });
  useEffect(() => {
    if (typeof window !== "undefined") {
      localStorage.setItem("sidebar-collapsed", collapsed ? "1" : "0");
    }
  }, [collapsed]);

  const [mobileOpen, setMobileOpen] = useState(false);
  useEffect(() => {
    if (view === "mobile") setMobileOpen(false);
    else if (view === "tablet") {
      const saved = typeof window !== "undefined" ? localStorage.getItem("sidebar-collapsed") : null;
      if (saved == null) setCollapsed(true);
    }
  }, [view]);

  const sidebarWidth = useMemo(() => {
    if (view === "mobile") return mobileOpen ? "16rem" : "0rem";
    return collapsed ? "4rem" : "16rem";
  }, [view, collapsed, mobileOpen]);

  const isOverlay = view === "mobile";

  const [caption, setCaption] = useState("Captivating caption generated by AI for your stunning image.");
  const [fontFamily, setFontFamily] = useState("Arial");
  const [fontSize, setFontSize] = useState(24);
  const [textColor, setTextColor] = useState<string>("#FFFFFF");
  const [align, setAlign] = useState<"left" | "center" | "right">("center");

  const [showBg, setShowBg] = useState(true);
  const [bgColor, setBgColor] = useState<string>("#3B3F4A");
  const [bgOpacity, setBgOpacity] = useState<number>(0.8);

  const [pos, setPos] = useState<{ x: number; y: number }>({ x: 120, y: 120 });
  const frameRef = useRef<HTMLDivElement | null>(null);
  const bubbleRef = useRef<HTMLDivElement | null>(null);
  const NUDGE = 10;

  const [dragging, setDragging] = useState(false);
  const [maybeDragging, setMaybeDragging] = useState(false);
  const startPt = useRef<{ x: number; y: number }>({ x: 0, y: 0 });
  const dragOffset = useRef<{ x: number; y: number }>({ x: 0, y: 0 });
  const DRAG_THRESHOLD = 6;

  const clampPosition = (nx: number, ny: number) => {
    const frame = frameRef.current;
    const bubble = bubbleRef.current;
    if (!frame || !bubble) return { x: nx, y: ny };
    const frameRect = frame.getBoundingClientRect();
    const bubbleRect = bubble.getBoundingClientRect();
    const pad = 0;
    const minX = pad, minY = pad;
    const maxX = Math.max(0, frameRect.width - bubbleRect.width - pad);
    const maxY = Math.max(0, frameRect.height - bubbleRect.height - pad);
    return { x: Math.min(Math.max(nx, minX), maxX), y: Math.min(Math.max(ny, minY), maxY) };
  };

  const nudge = (dx: number, dy: number) => setPos((p) => clampPosition(p.x + dx, p.y + dy));

  const applyAlign = (a: "left" | "center" | "right") => {
    const frame = frameRef.current;
    const bubble = bubbleRef.current;
    if (!frame || !bubble) {
      setAlign(a);
      return;
    }
    const frameRect = frame.getBoundingClientRect();
    const bubbleRect = bubble.getBoundingClientRect();
    const pad = 12;
    let x = pos.x;
    if (a === "left") x = pad;
    if (a === "center") x = Math.max(pad, (frameRect.width - bubbleRect.width) / 2);
    if (a === "right") x = Math.max(pad, frameRect.width - bubbleRect.width - pad);
    setPos((p) => clampPosition(x, p.y));
    setAlign(a);
  };

  const centerPosition = () => {
    const frame = frameRef.current;
    const bubble = bubbleRef.current;
    if (!frame || !bubble) return;
    const frameRect = frame.getBoundingClientRect();
    const bubbleRect = bubble.getBoundingClientRect();
    const pad = 12;
    const x = Math.max(pad, (frameRect.width - bubbleRect.width) / 2);
    const y = Math.max(pad, (frameRect.height - bubbleRect.height) / 2);
    setPos(clampPosition(x, y));
  };

  const onBubblePointerDown: React.PointerEventHandler<HTMLDivElement> = (e) => {
    if (e.pointerType === "mouse" && e.button !== 0) return;
    const bubble = bubbleRef.current;
    if (!bubble) return;

    setMaybeDragging(true);
    startPt.current = { x: e.clientX, y: e.clientY };

    const bubbleRect = bubble.getBoundingClientRect();
    dragOffset.current = { x: e.clientX - bubbleRect.left, y: e.clientY - bubbleRect.top };
  };

  const onBubblePointerMove: React.PointerEventHandler<HTMLDivElement> = (e) => {
    const frame = frameRef.current;
    if (!frame) return;

    if (!dragging && maybeDragging) {
      const dx = e.clientX - startPt.current.x;
      const dy = e.clientY - startPt.current.y;
      if (Math.hypot(dx, dy) >= DRAG_THRESHOLD) {
        (e.target as Element)?.setPointerCapture?.(e.pointerId);
        setDragging(true);
      } else {
        return;
      }
    }

    if (!dragging) return;

    const frameRect = frame.getBoundingClientRect();
    const nx = e.clientX - frameRect.left - dragOffset.current.x;
    const ny = e.clientY - frameRect.top - dragOffset.current.y;
    setPos(clampPosition(nx, ny));

    e.preventDefault();
  };

  const onBubblePointerUp: React.PointerEventHandler<HTMLDivElement> = (e) => {
    if (dragging) {
      (e.target as Element)?.releasePointerCapture?.(e.pointerId);
    }
    setDragging(false);
    setMaybeDragging(false);
  };

  useEffect(() => {
    const frame = frameRef.current;
    const bubble = bubbleRef.current;
    if (!frame || !bubble) return;

    const reClamp = () => {
      requestAnimationFrame(() => setPos((p) => clampPosition(p.x, p.y)));
    };

    const ro = new ResizeObserver(reClamp);
    ro.observe(frame);
    ro.observe(bubble);

    const onOrient = () => reClamp();
    window.addEventListener("orientationchange", onOrient);

    return () => {
      ro.disconnect();
      window.removeEventListener("orientationchange", onOrient);
    };
  }, []);

  useEffect(() => {
    requestAnimationFrame(() => setPos((p) => clampPosition(p.x, p.y)));
  }, [view]);

  const bubbleStyle: React.CSSProperties = {
    transform: `translate(${pos.x}px, ${pos.y}px)`,
    left: 0,
    top: 0,
    color: textColor,
    fontFamily,
    fontSize,
    textAlign: align as React.CSSProperties["textAlign"],
    backgroundColor: showBg ? bgColor : "transparent",
    opacity: showBg ? bgOpacity : 1,
    cursor: dragging ? "grabbing" : "grab",
    userSelect: "none",
    touchAction: dragging ? "none" : "auto",
    willChange: "transform",
  };

  const COLORS = ["#FFFFFF", "#000000", "#3b477e", "#2ECC71", "#3498DB", "#F1C40F", "#E74C3C", "#9B59B6"];

  return (
    <div
      className="bg-[#0C0F14] text-white overflow-x-hidden min-h-[100svh]"
      style={{ ["--sidebar-w" as string]: sidebarWidth }}
    >
      <Sidebar
        mode={isOverlay ? "overlay" : "docked"}
        open={isOverlay ? mobileOpen : true}
        collapsed={isOverlay ? false : collapsed}
        onToggle={() => (isOverlay ? setMobileOpen((o) => !o) : setCollapsed((v) => !v))}
        onClose={() => setMobileOpen(false)}
      />
      <div
        className="grid min-h-screen grid-rows-[auto,1fr,auto] transition-[padding-left] duration-500 ease-[cubic-bezier(0.25,0.8,0.25,1)]"
        style={{ paddingLeft: isOverlay ? 0 : "var(--sidebar-w)" }}
      >
        <Topbar isOverlay={isOverlay} mobileOpen={mobileOpen} onMobileToggle={() => setMobileOpen((o) => !o)} />

        <main className="h-full min-h-0 bg-black overflow-visible lg:overflow-auto pb-24 lg:pb-0">
          <section className="min-h-full flex flex-col lg:flex-row">
            <div className="flex-1 min-h-full flex items-center justify-center border-r border-white/10 bg-black">
              <div className="w-full max-w-[820px] p-4 md:p-6">
                <EditorPreview
                  image={preview_img}
                  caption={caption}
                  bubbleStyle={bubbleStyle}
                  frameRef={frameRef}
                  bubbleRef={bubbleRef}
                  showBg={showBg}
                  bubbleProps={{
                    onPointerDown: onBubblePointerDown,
                    onPointerMove: onBubblePointerMove,
                    onPointerUp: onBubblePointerUp,
                  }}
                />
              </div>
            </div>

            {/* Controls column */}
            <div className="w-full lg:w-[400px] min-h-0 lg:min-h-full border-l border-white/10 bg-[#0C0F14] flex flex-col">
              <EditorControls
                caption={caption}
                setCaption={setCaption}
                fontFamily={fontFamily}
                setFontFamily={setFontFamily}
                fontSize={fontSize}
                setFontSize={setFontSize}
                textColor={textColor}
                setTextColor={setTextColor}
                align={align}
                applyAlign={applyAlign}
                showBg={showBg}
                setShowBg={setShowBg}
                bgColor={bgColor}
                setBgColor={setBgColor}
                bgOpacity={bgOpacity}
                setBgOpacity={setBgOpacity}
                COLORS={COLORS}
                nudge={nudge}
                centerPosition={centerPosition}
                NUDGE={NUDGE}
              />
            </div>
          </section>
        </main>

        <Footer />
      </div>
    </div>
  );
}